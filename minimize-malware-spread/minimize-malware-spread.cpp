class dsu{
    public:
        vector<int> parent;
        vector<int> rk;
        vector<int> sz;
        dsu(int n ){
            parent.resize(n,-1);
            rk.resize(n,0);
            sz.resize(n,1);
        }
        void init(int i ){
            parent[i] =i;
            
        }
        int find(int i){
            if(parent[i] == i)return i;
            return parent[i] = find(parent[i]);
        }
    int get_size(int i){
        return sz[find(i)];
    }
    bool merge(int i, int j)
    {
        i = find(i);
        j = find(j);
        if(i==j) return false;
        if(rk[i] < rk[j]) swap(i,j);
        parent[j] = i;
        if(rk[i]==rk[j]) rk[i]++;
        sz[i]+=sz[j];
        return true;
    }
};
class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        dsu d(n);
        for(int i =0;i<n;i++) d.init(i);
        for(int i =0;i<n;i++){
            for(int j =0;j<n;j++){
                if(graph[i][j]==1) d.merge(i,j);
            }
        }
        int m = initial.size();
        unordered_map<int,int> mp;
        int sum = 0;
        for(int i =0;i<m;i++){
            auto p = d.find(initial[i]);
            if(mp.count(p)==0){
                sum+=d.get_size(p);
            }   
            mp[p]++;
        }
        int mine = INT_MAX;
        int node = -1;
        for(int i= 0;i<m;i++){
            auto p = d.parent[initial[i]];
            int temp = sum;
            if(mp[p]==1) temp = sum - d.get_size(p);
            if(mine > temp){
                mine = temp;
                node = initial[i];
            }
            else if (mine ==temp){
                node = min(node,initial[i]);
            }
        }
        return node;
        
    }
};