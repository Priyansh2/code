class dsu{
    public:
        vector<int> parent;
        vector<int> rk;
        vector<int> sz;
        dsu(int n ){
            parent.resize(n,-1);
            rk.resize(n,0);
            sz.resize(n,1);
        }
        void init(int i ){
            parent[i] =i;
            
        }
        int find(int i){
            if(parent[i] == i)return i;
            return parent[i] = find(parent[i]);
        }
    int get_size(int i){
        return sz[find(i)];
    }
    bool merge(int i, int j)
    {
        i = find(i);
        j = find(j);
        if(i==j) return false;
        if(rk[i] < rk[j]) swap(i,j);
        parent[j] = i;
        if(rk[i]==rk[j]) rk[i]++;
        sz[i]+=sz[j];
        return true;
    }
};
class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        dsu d(n);
        for(int i =0;i<n;i++) d.init(i);
        for(int i =0;i<n;i++){
            for(int j =0;j<n;j++){
                if(graph[i][j]==1) d.merge(i,j);
            }
        }
        int m = initial.size();
        int node = -1;
        int maxe = INT_MIN;
        unordered_map<int,int> mp;
        for(auto x : initial){
            int par = d.find(x);
            mp[par]++;
        }
        for(auto x : initial){
            if(mp[d.parent[x]]!=1) continue;
            int size = d.get_size(d.parent[x]);
            if(maxe < size){
                maxe = size;
                node= x;
            }
            else if (maxe == size && node > x){
                node = x;
            }
        }
        if(node ==-1){
            node = *min_element(initial.begin(),initial.end());
        }
        return node;
        
    }
};