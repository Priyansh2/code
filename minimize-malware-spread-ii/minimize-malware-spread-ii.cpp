class Solution {
public:
    void dfs(int node, vector<vector<int>> &adj,unordered_set<int> &vis,vector<vector<int>> &graph,unordered_set<int> &infected, int &start){
        vis.insert(node);
        if(node!=start) adj[node].push_back(start);
        int n = graph.size();
        for(int i =0;i<n;i++){
            if(graph[node][i]==1 && vis.count(i)==0 && infected.count(i)==0) {
                dfs(i,adj,vis,graph,infected, start);
            }
        }
    }
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        /*
        make the graph g (adj. list) where there is directed edge a->b when b infects a directly. 
        conditions: 
        1. B must be any node from initial 
        2. We can reach A from B
        3. There is no other infected node other than B from every path from B to A.
        Answer will be minimum vlaue of infected node from which all noninfected nodes are uniquely infected. 
        If there is no such infected node exits then answer will be minimum value of infected node (min of initial nodes)
        
        */
        int n =  graph.size();
        vector<vector<int>> adj(n);
        unordered_set<int> infected(initial.begin(),initial.end());
        int m = initial.size();
        for(int i =0;i<m;i++){
            unordered_set<int> vis;
            dfs(initial[i],adj,vis,graph,infected,initial[i]);
        }
        unordered_map<int,int> mp;
        for(int i =0;i<n;i++){
            if(adj[i].size()==1) mp[adj[i][0]]++;
        }
        if(mp.empty()) {
            cout <<"sasa"<<endl;
            return *min_element(initial.begin(),initial.end());
        }
        int node =-1;
        int maxe = INT_MIN;
        for(auto &x : infected){
            if(mp.count(x)==0) continue;
            if( maxe < mp[x] ){
                maxe = mp[x];
                node = x; 
            }
            else if(maxe == mp[x] && node > x){
                node = x;
            }
        }
        return node;
    }
};